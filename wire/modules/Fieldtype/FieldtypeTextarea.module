<?php namespace ProcessWire;

/**
 * ProcessWire Textarea Fieldtype
 *
 * Stores a large block of multi-line text.
 *
 * For documentation about the fields used in this class, please see:  
 * /wire/core/Fieldtype.php
 * 
 * ProcessWire 3.x (development), Copyright 2015 by Ryan Cramer
 * https://processwire.com
 * 
 * Properties set to $field that is using this type, acceessed by $field->get('property'):
 *
 * - contentType (int): Content type of field output using a self::contentType* constant (default=self::contentTypeUnknown)
 * - htmlOptions (array): Options for content-type Markup/HTML using self::html* constants (default=null or blank array)
 * - inputfieldClass (string): Inputfield class/module name to use for this field (default=InputfieldTextarea)
 *
 */

class FieldtypeTextarea extends FieldtypeText {
	
	public static function getModuleInfo() {
		return array(
			'title' => 'Textarea',
			'version' => 105,
			'summary' => 'Field that stores multiple lines of text',
			'permanent' => true,
		);
	}

	/**
	 * The default Inputfield class associated with this Fieldtype
	 *
	 */
	const defaultInputfieldClass = 'InputfieldTextarea';

	/**
	 * Indicates an unknown or plain text content type
	 *
 	 */
	const contentTypeUnknown = 0;

	/**
	 * Indicates a Markup/HTML content type with basic root path QA
	 *
	 */
	const contentTypeHTML = 1;

	/**
	 * Indicates a Markup/HTML content type with all htmlImage* options enabled
	 * 
	 */
	const contentTypeImageHTML = 2;

	/**
	 * HTML options: <a> tag management to abstract page URLs in href attributes so they can be dynamically updated
	 *
	 */
	const htmlLinkAbstract = 2; 
	
	/**
	 * HTML options: <img> tag management to replace blank alt attributes with file description
	 * 
	 */
	const htmlImageReplaceBlankAlt = 4;
	
	/**
	 * HTML options: <img> tag management to remove or re-create images that don't exist
	 *
	 */
	const htmlImageRemoveNoExists = 8;
	
	/**
	 * HTML options: <img> tag management to remove images that user doesn't have access to
	 *
	 */
	const htmlImageRemoveNoAccess = 16;


	/**
	 * Instance of MarkupQA 
	 * 
	 * @var MarkupQA
	 * 
	 */
	protected $markupQA = null;

	public function init() {
		$this->set('inputfieldClass', self::defaultInputfieldClass); 
		$this->set('contentType', self::contentTypeUnknown); 
		$this->set('htmlOptions', array());
		parent::init();
	}

	public function sanitizeValue(Page $page, Field $field, $value) {
		return parent::sanitizeValue($page, $field, $value); 
	}

	public function ___markupValue(Page $page, Field $field, $value = null, $property = '') {
		if(is_null($value)) $value = $page->getFormatted($field->name);
		if($field->get('contentType') >= self::contentTypeHTML) {
			$value = $this->formatValue($page, $field, $value); 	
		} else {
			$value = parent::___markupValue($page, $field, $value, $property);
		}
		return $value; 
	}
	
	public function ___formatValue(Page $page, Field $field, $value) {
		$value = parent::___formatValue($page, $field, $value);
		return $value; 
	}

	public function ___sleepValue(Page $page, Field $field, $value) {
		$value = parent::___sleepValue($page, $field, $value);
		if($field->get('contentType') >= self::contentTypeHTML) $this->htmlReplacements($page, $field,$value, true);
		return $value; 
	}
	
	public function ___wakeupValue(Page $page, Field $field, $value) {
		// note: we do this here in addition to loadPageField to account for values that came
		// from external resources (not loaded from DB). 
		$value = parent::___wakeupValue($page, $field, $value);
		if($field->get('contentType') >= self::contentTypeHTML) {
			$this->htmlReplacements($page, $field, $value, false);
		}
		return $value;
	}
	
	public function ___loadPageField(Page $page, Field $field) {
		$value = parent::___loadPageField($page, $field);
		if($field->get('contentType') >= self::contentTypeHTML) {
			$this->htmlReplacements($page, $field, $value, false);
		}
		return $value; 
	}

	/**
	 * Get the MarkupQA instance
	 * 
	 * @param Page $page
	 * @param Field $field
	 * @return MarkupQA
	 * @throws WireException If called the first time without page or field arguments
	 * 
	 */
	public function markupQA(Page $page = null, Field $field = null) {
		if(is_null($this->markupQA)) {
			if(!$page || !$field) throw new WireException("markupQA needs a Page and Field argument the first time it is called");
			$this->markupQA = $this->wire(new MarkupQA($page, $field));
		} else {
			if($page) $this->markupQA->setPage($page);
			if($field) $this->markupQA->setField($field);
		}
		return $this->markupQA;
	}

	/**
	 * Content Type HTML replacements accounting for href and src attributes
	 * 
	 * This ensures that sites migrated from one subdirectory to another, or from a subdirectory to
	 * a non-subdir, or non-subdir to a subdir, continue working. This adds runtime context
	 * to 'href' and 'src' attributes in HTML.
	 *
	 * This method modifies the $value directly rather than returning it.
	 *
	 * In order to make the abstracted attributes identifiable to this function (so they can be reversed)
	 * it replaces the space preceding the attribute name with a tab character. This ensures the HTML
	 * underneath still remains compliant in case it is later extracted directly from the DB for
	 * data conversion or something like that. 
	 * 
	 * This one handles a string value or array of string values (like for multi-language support)
	 * 
	 * Note: this is called by both loadPageField and wakeupValue, so will be called with the same
	 * arguments twice during load of a value
	 * 
	 * @param Page $page
	 * @param Field $field
 	 * @param string|array $value Value to look for attributes (or array of values)
	 * @param bool $sleep When true, convert links starting with root URL to "/". When false, do the reverse. 
	 * 	
	 */
	protected function htmlReplacements(Page $page, Field $field, &$value, $sleep = true) {
		
		$languages = $this->wire('languages');
		
		if(is_array($value)) {
			// array of values, most likely multi-language data123 columns from loadPageField 
			foreach($value as $k => $v) {
				if(is_string($v)) {
					$this->_htmlReplacement($page, $field, $v, $sleep);
				} else {
					$this->htmlReplacements($page, $field, $v, $sleep); // recursive
				}
				$value[$k] = $v;
			}
			
		} else if(is_object($value) && $languages && $value instanceof LanguagesValueInterface && $value instanceof Wire) {
			// most likely a LanguagesPageFieldValue, but can be any type implementing LanguagesValueInterface
			/** @var Wire|LanguagesValueInterface $value */
			$trackChanges = $value->trackChanges();
			$value->setTrackChanges(false);
			foreach($languages as $language) {
				/** @var LanguagesValueInterface $value */
				$v = $value->getLanguageValue($language->id);
				$this->_htmlReplacement($page, $field, $v, $sleep);
				$value->setLanguageValue($language, $v, $field);
			}
			if($trackChanges) $value->setTrackChanges($trackChanges);
			
		} else if(is_string($value)) {
			// standard textarea string
			$this->_htmlReplacement($page, $field, $value, $sleep);
		}
	}

	/**
	 * Helper for htmlReplacements, to process single value
	 * 
	 * @param Page $page
	 * @param Field $field
	 * @param string $value
	 * @param bool $sleep
	 * 
	 */
	protected function _htmlReplacement(Page $page, Field $field, &$value, $sleep) {
	
		if(!strlen($value)) return;
		
		$markupQA = $this->markupQA($page, $field);
		$contentType = $field->get('contentType');
		$htmlOptions = $field->get('htmlOptions');
		
		if(!is_array($htmlOptions)) $htmlOptions = array();

		if($sleep) {
			$markupQA->sleepUrls($value);
			if(in_array(self::htmlLinkAbstract, $htmlOptions)) $markupQA->sleepLinks($value);
		
			/*
			$flags = 0;
			foreach($htmlOptions as $opt) {
				$opt = (int) $opt;
				$flags = $flags | $opt;
			}
			$value .= "<!-- PWMQ PWMQ$flags -->";
			*/

		} else {
			// $pos = strrpos($value, "<!-- PWMQ ");
			if(in_array(self::htmlLinkAbstract, $htmlOptions)) $markupQA->wakeupLinks($value);
			$markupQA->wakeupUrls($value);
			$useCheckImg = false;
			if($contentType == self::contentTypeImageHTML) {
				// keep default options, which means all enabled
				$opts = array();
				$useCheckImg = true;
			} else {
				// set image options specifically
				$opts = array(
					'replaceBlankAlt' => in_array(self::htmlImageReplaceBlankAlt, $htmlOptions),
					'removeNoExists' => in_array(self::htmlImageRemoveNoExists, $htmlOptions),
					'removeNoAccess' => in_array(self::htmlImageRemoveNoAccess, $htmlOptions)
				);
				foreach($opts as $val) if($val) $useCheckImg = true;
			}
			if($useCheckImg) $markupQA->checkImgTags($value, $opts);
		}
	}

	/**
	 * Get the Inputfield module that provides input for Field
	 * 
	 * @param Page $page
	 * @param Field $field
	 * @return Inputfield
	 * 
	 */
	public function getInputfield(Page $page, Field $field) {

		$inputfieldClass = $field->get('inputfieldClass');
		
		if($inputfieldClass) {
			$inputfield = $this->modules->getModule($inputfieldClass, array('noSubstitute' => true)); 
		} else {
			$inputfield = $this->modules->get(self::defaultInputfieldClass); 
		}
		
		if(!$inputfield) {
			$inputfield = $this->modules->get(self::defaultInputfieldClass);
			$this->getInputfieldError($field);
		}
		
		$inputfield->class = $this->className();
		return $inputfield; 
	}

	/**
	 * Handle error condition when getInputfield() fails to retrieve requested Inputfield
	 * 
	 * @param Field $field
	 *
	 */
	protected function getInputfieldError(Field $field) {
		
		$editURL = $this->wire('config')->urls->admin . "setup/field/edit?id=$field->id";
		$modulesURL = $this->wire('config')->urls->admin . "module/";
		$inputfieldClass = $field->get('inputfieldClass');
		$findURL = "http://modules.processwire.com/search/?q=$inputfieldClass";
		$tab = '<br /> &nbsp; &nbsp; &nbsp;';

		$note = 
			"<br /><small>TO INSTALL:$tab 1. <a href='$modulesURL'>Go to Modules</a>.$tab 2. click the \"New\" tab. " . 
			"$tab 3. For \"Module Class Name\" paste in \"$inputfieldClass\". $tab 4. Click \"Download &amp; Install\"." . 
			"<br />TO CHANGE: $tab 1. <a href='$editURL'>Edit the field</a>. $tab 2. Click the \"Details\" tab. " . 
			"$tab 3. Select the \"Inputfield Type\". $tab 4. Click \"Save\".</small>";

		if($inputfieldClass == 'InputfieldTinyMCE') {
			$this->wire('modules')->getInstall('InputfieldCKEditor'); // install it so it's ready for them
			$this->error(
				"Field '$field->name' uses TinyMCE, which is no longer part of the core. " .
				"Please install <a target='_blank' href='$findURL'>TinyMCE</a> " .
				"or change it to use CKEditor (or another).$note",
				Notice::allowMarkup);

		} else if($inputfieldClass) {
			$this->error(
				"The module \"$inputfieldClass\" specified to provide input for field \"$field->name\" was not found. " .
				"Please <a target='_blank' href='$findURL'>install $inputfieldClass</a> " .
				"or convert the field to use another input type.$note",
				Notice::allowMarkup);
		}
	}

	/**
	 * Get database schema used by the Field
	 * 
	 * @param Field $field
	 * @return array
	 * 
	 */
	public function getDatabaseSchema(Field $field) {
		$schema = parent::getDatabaseSchema($field); 
		$schema['data'] = 'mediumtext NOT NULL';
		$schema['keys']['data'] = 'FULLTEXT KEY data (data)'; 
		return $schema;
	}

	/**
	 * Get Inputfields to configure the Field
	 * 
	 * @param Field $field
	 * @return InputfieldWrapper
	 * 
	 */
	public function ___getConfigInputfields(Field $field) {

		$inputfields = parent::___getConfigInputfields($field);
		
		$value = $field->get('inputfieldClass');
		/** @var InputfieldSelect $f */
		$f = $this->modules->get('InputfieldSelect');
		$f->attr('name', 'inputfieldClass'); 
		$f->attr('value', $value ? $value : self::defaultInputfieldClass); 
		$f->label = $this->_('Inputfield Type');
		$f->description = $this->_('The type of field that will be used to collect input (Textarea is the default). Note that if you change this and submit, the available configuration options in the "input" tab section may change.'); // Inputfield type description
		$f->required = true; 

		$baseClass = "InputfieldTextarea";
		foreach($this->wire('modules')->find("className^=Inputfield") as $fm) {
			if("$fm" == $baseClass || is_subclass_of($fm->className(true), __NAMESPACE__ . "\\$baseClass")) {
				$f->addOption("$fm", str_replace("Inputfield", '', "$fm"));
			}
		}

		$inputfields->append($f); 	
		
		$htmlLabel = $this->_('Markup/HTML');
		$typeLabel = $this->_('Content Type');
		
		$f = $this->modules->get('InputfieldRadios'); 
		$f->attr('name', 'contentType'); 
		$f->label = $typeLabel;
		$f->addOption(self::contentTypeUnknown, $this->_('Unknown/Text')); 
		$f->addOption(self::contentTypeHTML, $htmlLabel);
		$value = (int) $field->get('contentType');
		// note: if adding more content types, update the ">=" below to be just "="
		if($value >= self::contentTypeImageHTML) $value = self::contentTypeHTML;
		$f->attr('value', $value); 
		$f->description = $this->_('The [u]Markup/HTML[/u] option is recommended for fields using rich text editors (like CKEditor) and those containing HTML. It provides additional runtime checks filtering for quality assurance.'); // Content type description
		$f->description .= ' ' . $this->_('If you select the [u]Unknown/Text[/u] option, it is strongly recommended [for security] that you also select the "HTML Entity Encoder" in the [u]Text Formatters[/u] field above.');
		$f->notes = sprintf($this->_('For more information about the options above see [description of content type options](%s).'), 'https://processwire.com/api/fieldtypes/textarea-fieldtype/#content-type'); 
		$inputfields->append($f);
		
		$fieldset = $this->wire('modules')->get('InputfieldFieldset');
		$fieldset->label = "$htmlLabel ($typeLabel)";
		$fieldset->icon = 'html5';
		$fieldset->showIf = 'contentType=' . self::contentTypeHTML;
		$inputfields->add($fieldset);

		$f = $this->modules->get('InputfieldCheckboxes');
		$f->attr('name', 'htmlOptions');
		$f->label = $this->_('HTML Options');
		$f->description = $this->_('The following options provide additional quality assurance for HTML at runtime.');
		// For more information about these options see [description of Markup/HTML options](%s).'), 'https://processwire.com/api/fieldtypes/textarea-fieldtype/#markup-html-options');
		$f->notes = $this->_('**Note:** These options are currently experimental. Please watch for issues and report any errors.');
		$f->notes .= ' ' . $this->_('The options above log errors to Setup > Logs > markup-qa-errors.'); 
		$f->addOption(self::htmlLinkAbstract,
			$this->_('Link abstraction:') . ' ' .
			'[span.description]' .
			$this->_('Update href attributes automatically when internal links change') .
			'[/span]'
		);
		$f->addOption(self::htmlImageReplaceBlankAlt, 
			$this->_('Update image alt attributes:') . ' ' . 
			'[span.description]' . 
			$this->_('Replace blank alt attributes with image description') . 
			'[/span]'
		);
		$f->addOption(self::htmlImageRemoveNoExists, 
			$this->_('Fix broken images:') . ' ' . 
			'[span.description]' . 
			$this->_('Remove img tags that would result in a 404, or re-create images when possible') . 
			'[/span]'
		);
		$f->addOption(self::htmlImageRemoveNoAccess, 
			$this->_('Image access control:') . ' ' . 
			'[span.description]' . 
			$this->_('Remove images from markup that user does not have view access to') . 
			'[/span]'
		);
		$value = $field->get('htmlOptions');
		if(!is_array($value)) $value = array();
		if($field->get('contentType') == self::contentTypeImageHTML) {
			// if previous contentTypeImageHTML is in use, all HTML image options are implied
			$value[] = self::htmlImageReplaceBlankAlt;
			$value[] = self::htmlImageRemoveNoExists;
			$value[] = self::htmlImageRemoveNoAccess;
		}
		$f->attr('value', $value);
		$f->icon = 'sliders';
		$fieldset->add($f);
	
		/** @var InputfieldCheckbox $f */
		$f = $this->wire('modules')->get('InputfieldCheckbox');
		$f->attr('name', '_applyHTML');
		$f->label = $this->_('Apply HTML Options Now');
		$f->description = $this->_('To apply the above options to all existing pages right now, check this box. This primarily focuses on the link abstraction option.');
		$f->notes = $this->_('Warning, this performs an update across potentially hundreds of pages (max 300 per run) and updates page modification times. If your site has a lot of pages, you may have to run this multiple times.'); 
		$f->notes .= ' ' . $this->_('**As an extra precaution it is recommended that you backup your database before running this.**');
		$f->icon = 'bolt';
		$f->collapsed = Inputfield::collapsedYes;
		$f->showIf = 'htmlOptions=' . self::htmlLinkAbstract;
		$fieldset->add($f);
		
		if($this->wire('input')->post('_applyHTML') && $this->wire('process') == 'ProcessField') {
			$this->set('_applyFieldHTML', $field);
			$this->wire('session')->addHookBefore('redirect', $this, '_applyFieldHTML');
		}
		
		return $inputfields; 
	}

	/**
	 * Apply all htmlOptions to field values (hook to ProcessField::executed)
	 * 
	 * @param HookEvent $event
	 * @throws WireException
	 * 
	 */
	public function _applyFieldHTML(HookEvent $event) {
		set_time_limit(3600);
		$field = $this->get('_applyFieldHTML');
		if(!$field || !$field instanceof Field || !$field->type instanceof FieldtypeTextarea) return;
		$selector = "$field->name%=href|src, include=all";
		$total = $this->wire('pages')->count($selector);
		if($total > 300) {
			// more than 300 pages to update, only update those that haven't been modified in the last hour
			$modified = time() - 3600;
			$selector .= "limit=300, modified<=$modified";
		}
		$items = $this->wire('pages')->find($selector);
		$totals = array();
		foreach($items as $item) {
			$item->getUnformatted($field->name);
			$item->trackChange($field->name);
			$item->save($field->name);
			$info = $item->get('_markupQA_sleepLinks');
			if($info && isset($info[$field->name])) {
				$counts = $info[$field->name];
				foreach($counts as $key => $value) {
					if(!isset($totals[$key])) $totals[$key] = 0;
					$totals[$key] += $value;
				}
			}
		}
		$this->wire('pages')->touch($items, time());
		$this->wire('session')->message(
			sprintf($this->_('Updated %1$d out of %2$d pages for HTML options'), count($items), $total)
		);
		if(count($totals['internal'])) {
			$this->wire('session')->message(sprintf($this->_('Abstracted %d internal link(s)'), $totals['internal']));
		}
	}
	

}

