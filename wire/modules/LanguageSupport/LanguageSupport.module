<?php


/**
 * Main multi-language support module
 *
 * This module is the front door to all the other language modules and files. 
 *
 * ProcessWire 2.x 
 * Copyright (C) 2011 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class LanguageSupport extends WireData implements Module, ConfigurableModule {

	/**
	 * Return information about the module
	 *
	 */
        static public function getModuleInfo() {
                return array(
                        'title' => 'Languages Support',
                        'version' => 100,
                        'summary' => 'ProcessWire multi-language support. Installing this module will install the rest.',
			'author' => 'Ryan Cramer',
			'autoload' => true,
			'singular' => true,
			'installs' => array(
				'ProcessLanguage', 
				'ProcessLanguageTranslator', 
				'FieldtypeTextLanguage', 
				'FieldtypeTextareaLanguage'
				)
                        );
        }

	/**
	 * Name of template used for language pages
	 *
	 */
	const languageTemplateName = 'language';

	/**
	 * Name of field used to store the language page ref
	 *
	 */
	const languageFieldName = 'language';

	/**
 	 * This module can possibly be init'd before PW's Modules class fully loads, so we keep this to prevent double initialization
	 *
	 */
	protected $initialized = false; 

	/**
	 * Cached names of fields that are dealing in multiple languages. 
	 *
	 */
	protected $multilangFields = array();

	/**
	 * Construct and set our dynamic config vars
	 *
	 */
	public function __construct() {

		// load other required classes
		$dirname = dirname(__FILE__); 
		require_once($dirname . '/FieldtypeLanguageInterface.php'); 
		require_once($dirname . '/Language.php'); 
		require_once($dirname . '/Languages.php'); 
		require_once($dirname . '/LanguageTranslator.php'); 
		require_once($dirname . '/LanguagesPageFieldValue.php'); 

		// set our config var placeholders
		$this->set('languagesPageID', 0); 
		$this->set('defaultLanguagePageID', 0); 
		$this->set('languageTranslatorPageID', 0); 
	}

	/**
	 * Initialize the language support API vars
	 *
	 */
	public function init() {

		// prevent possible double init
		if($this->initialized) return; 
		$this->initialized = true; 

		$defaultLanguagePage = null;
		$defaultLanguagePageID = $this->defaultLanguagePageID; 

		// create the $languages API var
		$languages = new Languages($this->templates->get('language'), $this->languagesPageID); 
		Wire::setFuel('languages', $languages); 

		// ensure all languages are loaded and get instantiated versions of system/default languages
		foreach($this->languages as $language) {
			if($language->id == $defaultLanguagePageID) $defaultLanguagePage = $language; 
		}

		// if the defaultLanguagePage is no longer available (deleted?), make it the system language
		$defaultLanguagePage->setIsDefaultLanguage();

		// identify the current language from the user, or set one if it's not already
		if($this->user->language && $this->user->language->id) {
			$language = $this->user->language; 
		} else {
			$language = $defaultLanguagePage; 
			$this->user->language = $language; 
		}

		wire('config')->dateFormat = $this->_('Y-m-d H:i:s'); // Sortable date format used in the admin
		setlocale(LC_ALL, $this->_('C')); // Value to pass to PHP's setlocale(LC_ALL, 'value') function when initializing this language // Default is: C

		// setup our hooks handled by this class
		$this->addHookAfter('Inputfield::render', $this, 'hookInputfieldRender'); 
		$this->addHookAfter('Inputfield::processInput', $this, 'hookInputfieldProcessInput'); 
		$this->addHookAfter('Field::getInputfield', $this, 'hookFieldGetInputfield'); 
		$this->addHookAfter('fieldtypeLanguageInterface::loadPageField', $this, 'FieldtypeLoadPageField'); 
		$this->addHookAfter('fieldtypeLanguageInterface::wakeupValue', $this, 'FieldtypeWakeupValue'); 
		$this->addHookAfter('fieldtypeLanguageInterface::sleepValue', $this, 'FieldtypeSleepValue'); 
		$this->addHookBefore('PageFinder::getQuery', $this, 'pageFinderGetQuery'); 
		$this->pages->addHook('added', $this, 'hookPageAdded'); 
		$this->pages->addHook('deleteReady', $this, 'hookPageDeleteReady'); 

		// styles used by our Inputfield hooks
		$this->config->styles->add($this->config->urls->LanguageSupport . "LanguageSupport.css"); 

		// keep track of which fields are multilanguage
		foreach(wire('fields') as $field) {
			if($field->type instanceof FieldtypeLanguageInterface) {
				$this->multilangFields[] = $field->name; 	
			}
		}
	}

	/**
	 * Hook into Inputfield::render to duplicate inputs for other languages
	 *
	 */
	public function hookInputfieldRender(HookEvent $event) {

		$inputfield = $event->object; 

		// provide an automatic translation for some system/default fields if they've not been overridden in the fields editor
		$name = $inputfield->attr('name'); 
		if($name == 'language' && $inputfield->label == 'Language') $inputfield->label = $this->_('Language'); // Label for 'language' field in user profile
			else if($name == 'email' && $inputfield->label == 'E-Mail Address') $inputfield->label = $this->_('E-Mail Address'); // Label for 'email' field in user profile
			else if($name == 'title' && $inputfield->label == 'Title') $inputfield->label = $this->_('Title'); // Label for 'title' field used throughout ProcessWire

		// if inputfield doesn't have a 'useLanguages' var set in it, then we're done, abort
		if(!$inputfield->useLanguages) return; 

		// originals
		$name = $inputfield->attr('name');
		$id = $inputfield->attr('id');
		$value = $inputfield->attr('value');

		$trackChanges = $inputfield->trackChanges(); 
		$inputfield->setTrackChanges(false); 
		$out = '';

		foreach(wire('languages') as $language) {
			$languageID = (int) $language->id; 

			if($languageID == $this->defaultLanguagePageID) {
				// default language
				$newID = $id;

				if(is_null($inputfield->get('value' . $languageID))) { 
					// value for default language is specified in 'value' attribute, so use existing rendering
					$o = $event->return; 
				} else {
					// value for default language is specified in a value{id} property, so re-render it
					$valueAttr = "value$languageID";
					$inputfield->setAttribute('value', $inputfield->$valueAttr); 
					$o = $inputfield->___render(); 
					
				}

			} else {
				// non-default language
				$newID = $id . "__$languageID";
				$newName = $name . "__$languageID";
				$inputfield->attr('id', $newID); 
				$inputfield->attr('name', $newName); 
				$valueAttr = "value$languageID";
				$inputfield->setAttribute('value', $inputfield->$valueAttr); 
				$o = $inputfield->___render(); 
			}

			$o = 	"\n<div class='LanguageSupport'>" . 
				"\n\t<label for='$newID' class='LanguageSupportLabel detail'>{$language->title}</label>" . $o . 
				"\n</div>";

			$out .= $o;
		}

		$inputfield->setAttribute('name', $name);
		$inputfield->setAttribute('id', $id);
		$inputfield->setAttribute('value', $value);
		$inputfield->setTrackChanges($trackChanges); 

		$event->return = $out; 
	}

	/**
	 * Hook into Inputfield::processInput to process input for other languages
	 *
	 */
	public function hookInputfieldProcessInput(HookEvent $event) {

		$inputfield = $event->object; 
		if(!$inputfield->useLanguages) return;
		$post = $event->arguments[0];

		// originals
		$name = $inputfield->attr('name');
		$id = $inputfield->attr('id');
		$value = $inputfield->attr('value');

		foreach(wire('languages') as $language) {
			$languageID = (int) $language->id; 	
			if($languageID == $this->defaultLanguagePageID) continue; 
			$newID = $id . "__$languageID";
			$newName = $name . "__$languageID";
			$inputfield->setTrackChanges(false);
			$inputfield->attr('id', $newID); 
			$inputfield->attr('name', $newName); 
			$valueAttr = "value$languageID";
			$inputfield->setAttribute('value', $inputfield->$valueAttr); 
			$inputfield->setTrackChanges(true);
			$inputfield->___processInput($post);
			$inputfield->set($valueAttr, $inputfield->attr('value')); 
			// $this->message($valueAttr . ': ' . $inputfield->attr('value')); 
		}

		$inputfield->setTrackChanges(false);
		$inputfield->setAttribute('name', $name);
		$inputfield->setAttribute('id', $id);
		$inputfield->setAttribute('value', $value);
		$inputfield->setTrackChanges(true); 
		$inputfield->trackChange('value'); 

	}

	/**
	 * Hook into Field::getInputfield to change label/description to proper language
	 *
	 */
	public function hookFieldGetInputfield(HookEvent $event) {

		$language = wire('user')->language; 
		if(!$language) return; 

		$field = $event->object; 
		$inputfield = $event->return; 
		$translatable = array('label', 'description', 'notes');

		// populate language versions where available
		foreach($translatable as $key) {
			$langKey = $key . $language->id; // i.e. label1234
			$value = $field->$langKey; 
			if(!$value) continue; 
			$inputfield->$key = $value;
		}

		// see if this fieldtype supports languages natively
		if($field->type instanceof FieldtypeLanguageInterface) {

			// populate useLanguages in the inputfield so we can detect it elsehwere
			$inputfield->set('useLanguages', true); 

			$page = $event->arguments[0];
			$value = $page->get($field->name); 

			// set values in this field specific to each language
			foreach(wire('languages') as $language) {
				if(is_object($value) && $value instanceof LanguagesPageFieldValue) {
					$languageValue = $value->getLanguageValue($language->id);
				} else {
					if($language->isDefault) $languageValue = $value; 
						else $languageValue = '';
				}
				$inputfield->set('value' . $language->id, $languageValue); 	
			}
		}

		$event->return = $inputfield; 
	}

	/**
	 * Hook called when new language added
	 *
	 */
	public function hookPageAdded(HookEvent $event) {

		$page = $event->arguments[0];

		if($page->template->name != self::languageTemplateName) return; 

		foreach(wire('fields') as $field) { 
			if($field->type instanceof FieldtypeLanguageInterface) {
				$this->fieldLanguageAdded($field, $page); 
			}
		}

		// trigger hook in $languages
		wire('languages')->added($page);
	}

	/**
	 * Hook called when language is deleted
	 *
	 */
	public function hookPageDeleteReady(HookEvent $event) {

		$page = $event->arguments[0];
		if($page->template->name != self::languageTemplateName) return; 
		$language = $page; 

		// remove any language-specific values from any fields
		foreach(wire('fields') as $field) {

			$changed = false;

			foreach(array('label', 'description', 'notes') as $name) {
				$name = $name . $language->id;	
				if(!isset($field->$name)) continue;
				$field->remove($name);
				$this->message("Removed {$language->name} $name from field {$field->name}"); 
				$changed = true;
			}

			if($changed) $field->save();

			if($field->type instanceof FieldtypeLanguageInterface) $this->fieldLanguageRemoved($field, $language); 
		}

		// remove template labels
		foreach(wire('templates') as $template) {
			$name = 'label' . $page->id; 
			if(isset($template->$name)) {
				$template->remove($name); 
				$template->save();
				$this->message("Removed {$language->name} label from template {$template->name}"); 
			}
		}

		// trigger hook in $languages
		wire('languages')->deleted($page);

	}

	/**
	 * Called when a new language is added to the system for each field that implements FieldtypeLanguageInterface
	 *
	 */
	protected function ___fieldLanguageAdded(Field $field, Page $language) {

                if($language->isDefault) return;

                if(!($field->type instanceof FieldtypeLanguageInterface)) return;

                $schema = $field->type->getDatabaseSchema($field);

		foreach($schema as $name => $value) {
			if(!preg_match('/[^\d]+' . $language->id . '$/', $name)) continue; 
			// field in schema ends with the language ID
			$this->db->query("ALTER TABLE `{$field->table}` ADD `$name` $value"); 
		}

		foreach($schema['keys'] as $name => $value) {
			if(!preg_match('/[^\d]+' . $language->id . '$/', $name)) continue; 
			// index in schema ends with the language ID
			$this->db->query("ALTER TABLE `{$field->table}` ADD $value"); 
		}

	}
	
	/**
	 * Called when a language is removed from the system for each field that implements FieldtypeLanguageInterface
	 *
	 */
        public function ___fieldLanguageRemoved(Field $field, Page $language) {

                if($language->isDefault) return;

                if(!($field->type instanceof FieldtypeLanguageInterface)) return;

                $schema = $field->type->getDatabaseSchema($field);

		foreach($schema as $name => $value) {
			if(!preg_match('/[^\d]+' . $language->id . '$/', $name)) continue; 
			try { 
				$this->db->query("ALTER TABLE `{$field->table}` DROP COLUMN `$name`"); 
			} catch(Exception $e) { 
				// just catch, no need for fatal errors here
			}
		}

	}

	/**
	 * Hook into PageFinder::getQuery
	 *
	 * Adjusts the selectors passed to the query so that find operations search in user's native language version, as well as the default version.
	 *
	 * We may make this behavior configurable later on, as one may want to limit the search to 1 language only.
	 *
	 */
	public function pageFinderGetQuery(HookEvent $event) {

		$user = wire('user');
		if(!$user->language || $user->language->isDefault) return;

		$arguments = $event->arguments; 
		$selectors = $arguments[0]; 
		$changed = false; 

		foreach($selectors as $key => $selector) {

			$fields = $selector->field;
			$fields = is_array($fields) ? $fields : array($fields);

			foreach($fields as $key => $field) {
				$subfield = '';
				if(strpos($field, '.')) list($field, $subfield) = explode('.', $field); 
				if(!in_array($field, $this->multilangFields)) continue; 
				if(!$subfield) $subfield = 'data';

				if($subfield == 'data') {
					array_unshift($fields, "$field.$subfield{$user->language->id}"); 
					$changed = true; 
				}
			}

			if($changed) $selector->field = $fields;
		}

		$arguments[0] = $selectors; 
		$event->arguments = $arguments; 
	}

	public function fieldtypeLoadPageField(HookEvent $event) {
		$page = $event->arguments[0];
		$field = $event->arguments[1];
		$value = $event->return; 
		$event->return = new LanguagesPageFieldValue($value); 
	}

	public function fieldtypeWakeupValue(HookEvent $event) {
		$page = $event->arguments[0];
		$field = $event->arguments[1];
		$value = $event->return; 
		if(is_array($value)) $event->return = new LanguagesPageFieldValue($value); 
	}

	public function fieldtypeSleepValue(HookEvent $event) {
		$page = $event->arguments[0];
		$field = $event->arguments[1];
		$value = $event->return;

		$values = array();
		foreach(wire('languages') as $language) {
			if($language->isDefault) $key = 'data';
				else $key = 'data' . $language->id; 
			$values[$key] = $value->getLanguageValue($language->id); 
		}
		$event->return = $values; 
	}

	/**
	 * Module configuration screen
	 *
	 */
	public static function getModuleConfigInputfields(array $data) {
		$form = new InputfieldWrapper();
		return $form; 
	}

	/**
	 * Install or uninstall by loading the LanguageSupportInstall script
	 *
	 */
	protected function installer($install = true) {
		require_once($this->config->paths->LanguageSupport . 'LanguageSupportInstall.php'); 
		$installer = new LanguageSupportInstall();
		if($install) $installer->install();
			else $installer->uninstall();
	}

	/**
	 * Install the module
	 *
	 */
	public function ___install() {
		$this->installer(true); 
	}

	/**
	 * Uninstall the module
	 *
	 */
	public function ___uninstall() {
		$this->installer(false);
	}

}
